using System.Runtime.InteropServices;

namespace Seminar12
{
    public partial class Form1 : Form
    {
        int height, width;
        List<PointF> triangle;
        const int radius = 3;
        PointF center;
        public Form1()
        {
            InitializeComponent();
            triangle = new List<PointF>();
            height = ClientSize.Height;
            width = ClientSize.Width;
            center = new PointF(width / 2, height / 2);



        }

        private void Form1_Click(object sender, EventArgs e)
        {
            PointF newPoint = this.PointToClient(Form1.MousePosition);
            triangle.Add(newPoint);
            if (triangle.Count > 3)
            {
                triangle.RemoveAt(0);
            }
            if (triangle.Count == 3) {
                PointF p1 = triangle[0];
                PointF p2 = triangle[1];
                PointF p3 = triangle[2];
                center = Circumcenter(p1, p2, p3);
            }
            Invalidate();
        }

        private void Form1_Load(object sender, EventArgs e)
        {
            height = ClientSize.Height;
            width = ClientSize.Width;
        }

        private void Form1_Paint(object sender, PaintEventArgs e)
        {
            Graphics g = e.Graphics;
            #region plot points
            {
                
                for (int i = 0; i < triangle.Count; i++) {
                    PointF p = triangle[i];
                    float x = p.X;
                    float y = p.Y;
                    g.DrawEllipse(Pens.Navy,x-radius,y-radius,2*radius,2*radius);
                    string text = (i + 1).ToString();
                    g.DrawString(text,this.Font,Brushes.Navy,x-radius,y+radius);
                }
            }
            #endregion
            #region draw triangle sides
            if (triangle.Count >1) {
                for (int i = 0; i < triangle.Count; i++) {
                    int i1 = i;
                    int i2 = (i + 1 < triangle.Count) ? (i + 1) : 0;
                    PointF p1 = triangle[i1];
                    PointF p2 = triangle[i2];
                    g.DrawLine(Pens.Navy,p1,p2);
                }
            }
            #endregion
            #region plot circumcenter
            if (triangle.Count == 3) {
                g.DrawEllipse(Pens.Red,center.X-radius,center.Y-radius,2*radius,2*radius);
            }
            #endregion
            #region draw circumcircle
            if (triangle.Count == 3)
            {
                float dx = triangle[0].X - center.X;
                float dy = triangle[0].Y - center.Y;
                float radiusCircle = (float)Math.Sqrt(dx * dx + dy * dy);

                g.DrawEllipse(Pens.OrangeRed,
                    center.X - radiusCircle,
                    center.Y - radiusCircle,
                    2 * radiusCircle,
                    2 * radiusCircle);
            }
            #endregion
            #region draw perpendicular bisectors (mediatoare)
            if (triangle.Count == 3)
            {
                PointF[] p = triangle.ToArray();
                for (int i = 0; i < 3; i++)
                {
                    PointF p1 = p[i];
                    PointF p2 = p[(i + 1) % 3];

                    // Mijloc
                    float mx = (p1.X + p2.X) / 2;
                    float my = (p1.Y + p2.Y) / 2;

                    // Vector perpendicular (âˆ’dy, dx)
                    float dx = p2.X - p1.X;
                    float dy = p2.Y - p1.Y;

                    float len = 1000f;

                    PointF start = new PointF(mx - dy * len, my + dx * len);
                    PointF end = new PointF(mx + dy * len, my - dx * len);

                    g.DrawLine(Pens.Green, start, end);
                }
            }
            #endregion


        }
        public static PointF Circumcenter(PointF A, PointF B, PointF C)
        {
            // Coordonate
            float x1 = A.X, y1 = A.Y;
            float x2 = B.X, y2 = B.Y;
            float x3 = C.X, y3 = C.Y;

            // Determinanti
            float D = 2 * (x1 * (y2 - y3) +
                           x2 * (y3 - y1) +
                           x3 * (y1 - y2));

            if (D == 0)
                throw new ArgumentException("Punctele sunt coliniare - nu exista un cerc circumscris unic.");

            // Coordonatele centrului cercului
            float Ux = ((x1 * x1 + y1 * y1) * (y2 - y3) +
                        (x2 * x2 + y2 * y2) * (y3 - y1) +
                        (x3 * x3 + y3 * y3) * (y1 - y2)) / D;

            float Uy = ((x1 * x1 + y1 * y1) * (x3 - x2) +
                        (x2 * x2 + y2 * y2) * (x1 - x3) +
                        (x3 * x3 + y3 * y3) * (x2 - x1)) / D;

            return new PointF(Ux, Uy);
        }
    }
}
